package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/pelletier/go-toml/v2"
	ruleslib "github.com/xihale/snirect-shared/rules"
)

// Minimal type definitions to parse TOML (must match internal/config types)
type Config struct {
	CheckHostname interface{}   `toml:"check_hostname"`
	SetProxy      bool          `toml:"set_proxy"`
	CAInstall     string        `toml:"ca_install"`
	IPv6          bool          `toml:"ipv6"`
	ECS           string        `toml:"ecs"`
	DNS           DNSConfig     `toml:"DNS"`
	Timeout       TimeoutConfig `toml:"timeout"`
	Limit         LimitConfig   `toml:"limit"`
	Log           LogConfig     `toml:"log"`
	Server        ServerConfig  `toml:"server"`
}

type TimeoutConfig struct {
	Dial int `toml:"dial"`
	DNS  int `toml:"dns"`
}

type LimitConfig struct {
	MaxConns     int `toml:"max_connections"`
	DNSCacheSize int `toml:"dns_cache_size"`
}

type DNSConfig struct {
	Nameserver   []string `toml:"nameserver"`
	BootstrapDNS []string `toml:"bootstrap_dns"`
}

type LogConfig struct {
	Level string `toml:"loglevel"`
	File  string `toml:"logfile"`
}

type ServerConfig struct {
	Address string `toml:"address"`
	Port    int    `toml:"port"`
	PACHost string `toml:"pac_host"`
}

type Rules struct {
	AlterHostname map[string]string      `toml:"alter_hostname"`
	CertVerify    map[string]interface{} `toml:"cert_verify"`
	Hosts         map[string]string      `toml:"hosts"`
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	baseDir := "internal/config"
	if len(os.Args) > 1 {
		baseDir = os.Args[1]
	}

	configPath := filepath.Join(baseDir, "config.default.toml")
	configData, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	var cfg Config
	if err := toml.Unmarshal(configData, &cfg); err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	rulesData := []byte(ruleslib.FetchedRulesTOML)

	var rules Rules
	if err := toml.Unmarshal(rulesData, &rules); err != nil {
		return fmt.Errorf("failed to parse rules: %w", err)
	}

	// Generate code
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("// This file contains pre-parsed default configuration to avoid runtime TOML parsing.\n\n")
	buf.WriteString("package config\n\n")
	buf.WriteString("import ruleslib \"github.com/xihale/snirect-shared/rules\"\n\n")

	// Generate Config
	buf.WriteString("// PreparsedDefaultConfig contains the compile-time parsed default configuration.\n")
	buf.WriteString("var PreparsedDefaultConfig = ")
	if err := writeValue(&buf, reflect.ValueOf(cfg), 0); err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}
	buf.WriteString("\n\n")

	// Generate Rules - embed in ruleslib.Rules
	buf.WriteString("// PreparsedDefaultRules contains the compile-time parsed default rules.\n")
	buf.WriteString("var PreparsedDefaultRules = Rules{\n")
	buf.WriteString("\tRules: &ruleslib.Rules{\n")

	// Write AlterHostname
	if rules.AlterHostname != nil && len(rules.AlterHostname) > 0 {
		buf.WriteString("\t\tAlterHostname: ")
		if err := writeValue(&buf, reflect.ValueOf(rules.AlterHostname), 2); err != nil {
			return fmt.Errorf("failed to generate AlterHostname: %w", err)
		}
		buf.WriteString(",\n")
	}

	// Write CertVerify - ALWAYS initialize to avoid nil map panics during Merge
	buf.WriteString("\t\tCertVerify: ")
	if rules.CertVerify != nil && len(rules.CertVerify) > 0 {
		if err := writeValue(&buf, reflect.ValueOf(rules.CertVerify), 2); err != nil {
			return fmt.Errorf("failed to generate CertVerify: %w", err)
		}
	} else {
		buf.WriteString("map[string]interface{}{}")
	}
	buf.WriteString(",\n")

	// Write Hosts
	if rules.Hosts != nil && len(rules.Hosts) > 0 {
		buf.WriteString("\t\tHosts: ")
		if err := writeValue(&buf, reflect.ValueOf(rules.Hosts), 2); err != nil {
			return fmt.Errorf("failed to generate Hosts: %w", err)
		}
		buf.WriteString(",\n")
	}

	buf.WriteString("\t},\n")
	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Print the unformatted code for debugging
		fmt.Println(buf.String())
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write output
	outputPath := filepath.Join(baseDir, "defaults_generated.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("Generated %s\n", outputPath)
	return nil
}

// writeValue writes a Go literal representation of a value
func writeValue(buf *bytes.Buffer, v reflect.Value, indent int) error {
	if !v.IsValid() {
		buf.WriteString("nil")
		return nil
	}

	switch v.Kind() {
	case reflect.Bool:
		fmt.Fprintf(buf, "%t", v.Bool())

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		fmt.Fprintf(buf, "%d", v.Int())

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		fmt.Fprintf(buf, "%d", v.Uint())

	case reflect.Float32, reflect.Float64:
		fmt.Fprintf(buf, "%g", v.Float())

	case reflect.String:
		fmt.Fprintf(buf, "%q", v.String())

	case reflect.Slice:
		if v.IsNil() {
			buf.WriteString("nil")
			return nil
		}

		elemType := v.Type().Elem()
		fmt.Fprintf(buf, "[]%s{", getTypeName(elemType))

		for i := 0; i < v.Len(); i++ {
			if i > 0 {
				buf.WriteString(", ")
			}
			if err := writeValue(buf, v.Index(i), indent); err != nil {
				return err
			}
		}
		buf.WriteString("}")

	case reflect.Map:
		if v.IsNil() {
			buf.WriteString("nil")
			return nil
		}

		keyType := v.Type().Key()
		elemType := v.Type().Elem()
		fmt.Fprintf(buf, "map[%s]%s{", getTypeName(keyType), getTypeName(elemType))

		// Sort keys for deterministic output
		keys := v.MapKeys()
		sort.Slice(keys, func(i, j int) bool {
			return fmt.Sprint(keys[i].Interface()) < fmt.Sprint(keys[j].Interface())
		})

		if len(keys) > 0 {
			buf.WriteString("\n")
			for _, key := range keys {
				buf.WriteString(strings.Repeat("\t", indent+1))
				if err := writeValue(buf, key, indent+1); err != nil {
					return err
				}
				buf.WriteString(": ")
				if err := writeValue(buf, v.MapIndex(key), indent+1); err != nil {
					return err
				}
				buf.WriteString(",\n")
			}
			buf.WriteString(strings.Repeat("\t", indent))
		}
		buf.WriteString("}")

	case reflect.Struct:
		typeName := v.Type().Name()
		if typeName == "" {
			typeName = v.Type().String()
		}

		fmt.Fprintf(buf, "%s{\n", typeName)

		for i := 0; i < v.NumField(); i++ {
			field := v.Type().Field(i)

			// Skip unexported fields
			if !field.IsExported() {
				continue
			}

			fieldValue := v.Field(i)

			// Skip zero values for cleaner output (optional)
			if isZeroValue(fieldValue) {
				continue
			}

			buf.WriteString(strings.Repeat("\t", indent+1))
			fmt.Fprintf(buf, "%s: ", field.Name)

			if err := writeValue(buf, fieldValue, indent+1); err != nil {
				return err
			}
			buf.WriteString(",\n")
		}

		buf.WriteString(strings.Repeat("\t", indent))
		buf.WriteString("}")

	case reflect.Interface:
		if v.IsNil() {
			buf.WriteString("nil")
			return nil
		}
		// For interface{}, write the underlying concrete value
		return writeValue(buf, v.Elem(), indent)

	case reflect.Ptr:
		if v.IsNil() {
			buf.WriteString("nil")
			return nil
		}
		buf.WriteString("&")
		return writeValue(buf, v.Elem(), indent)

	default:
		return fmt.Errorf("unsupported type: %v", v.Type())
	}

	return nil
}

// getTypeName returns the Go type name for a reflect.Type
func getTypeName(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Interface:
		if t.NumMethod() == 0 {
			return "interface{}"
		}
		return t.String()
	case reflect.Map:
		return fmt.Sprintf("map[%s]%s", getTypeName(t.Key()), getTypeName(t.Elem()))
	case reflect.Slice:
		return fmt.Sprintf("[]%s", getTypeName(t.Elem()))
	case reflect.Ptr:
		return fmt.Sprintf("*%s", getTypeName(t.Elem()))
	default:
		if t.Name() != "" {
			return t.Name()
		}
		return t.String()
	}
}

// isZeroValue checks if a value is the zero value for its type
func isZeroValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.String:
		return v.String() == ""
	case reflect.Interface, reflect.Ptr, reflect.Slice, reflect.Map:
		return v.IsNil()
	case reflect.Struct:
		// For structs, check if all fields are zero
		for i := 0; i < v.NumField(); i++ {
			if !isZeroValue(v.Field(i)) {
				return false
			}
		}
		return true
	default:
		return false
	}
}
